# ISA 2: measures of dispersion and visualizing relationships

## R outcomes

After reading this chapter, you can: 

1. Generate and interpret measures of dispersion 
2. Create and interpret scatterplots (interval/ratio data) and crosstabulations (nominal and ordinal data) 
3. Recode existing data into new variables using `dplyr::mutate` 

## Required packages

You will need the following additional packages:

-   `dplyr` (but we will simply install the `tidyverse` collection so that we also have the pipe operator - `%>%` - loaded)
-   `haven`

```{r}
#| label: install_load
#| message: FALSE 
#| warning: FALSE

library(tidyverse)
library(haven)

```

## Open up your project and a new script file

You created a R project for your ISA work [in the last class](5_r_ISA1.qmd#sec-ISACh1), so open this now and also create a new R script (`Ctrl\Cmd` + `Shift` + `n`) so that you can save today's work.   

## Measures of dispersion

In this course, we will consider three measures of dispersion.

### The standard deviation

The standard deviation is defined as:

$$
S = \sqrt\frac{\sum_{i=1}^{n}{(x_i-\bar{x})^2}}{n-1}
$$


Computation of the standard deviation involves:

1. Calculating the sample mean $\bar{x}$
2. Subtracting $\bar{x}$ from each "raw" value of $x$ to compute deviations
3. Squaring the deviations from step 2 $(x_i - \bar{x})^2$
4. Summing the deviations $\sum_{i = 1}^{n}$
5. Dividing the deviations by the number of observations ($n$) minus 1
6. Taking the square root of 5

The standard deviation can be roughly interpreted as the average deviation from the sample mean in the data. Much like the mean, this measure of dispersion is mot appropriate for interval/ratio level data. 

### The range

The range is simply the difference between the maximum and minimum values in the data, and can be written as:

$$
range = max(x_1, x_2, ..., x_n) - min(x_1, x_2, ..., x_n)
$$

### The interquartile range (IQR)

This represents the spread of the middle 50% of the data and is calculated as:

$$
IQR = Q_3 - Q_1
$$

$Q_3$ and $Q_1$, are, respectively, the 75th and 25th percentiles of the data.To find these for data $x$ with $n$ elements:

* $Q_1(x) = x_{(\frac{n+1}{4})}$
  
* $Q_3(x) = x_{(\frac{3(n+1)}{4})}$
  
Where the position index for the quartile is not a whole number, we can average the values from the two nearest whole number positions to find our quartile. For example, for data with $n = 100$:

* $Q_1(x) = x_{(\frac{101}{4})} = 25.25$

In the above case, we would average the 25th- and 26th-ranked values of $x$ to find $Q_1(x)$.

## Measures of dispersion in R

Let's load in the World Data Indicators (WDI) dataset (`World_Data.sav`), where the cases (rows) are individual countries. We will then pick out the variable `wdi_internet` whose label we can print with the function `attibutes`, without having to print every value.

```{r ESSload, eval = FALSE}

wd<-haven::read_sav("World_Data.sav")
attributes(wd$wdi_internet)$label
```

```{r ESSloadreal, echo = FALSE}
wd<-haven::read_sav("C:/Users/David/OneDrive - UvA/2025_2026/ISA_24_25/Datasets/World_Data.sav")
attributes(wd$wdi_internet)$label
```

As you can see, this variable shows the percentage of individuals using the internet as percentage of population. We can will use `summary` to display some measures of central tendency:

```{r wdsummary}
summary(wd$wdi_internet)
```

(Along with these, we can see that four countries had [`NA` values](2_r_firstdata.qmd#nte-na) for this variable. We need to bear this in mind as we go further, because R will try to get answers out of `NA` entries where no answers are to be had.) 

### The standard deviation

```{r wdsd}

sd(wd$wdi_internet, na.rm = TRUE)

```

(The `na.rm = TRUE` argument above tells R to remove any values of `NA` before performing the requested operation.)


### The range

```{r wdrange}

range(wd$wdi_internet, na.rm = TRUE)

```

While the function runs, it actually returns the minimum and maximum values of the dataset, rather than the difference between them. We can add some extra code to calculate this:

```{r wdrangediff}

range(wd$wdi_internet, na.rm = TRUE)[2] - range(wd$wdi_internet, na.rm = TRUE)[1] 

```

This tells R to subtract the first output argument from the `range` function (the minimum value) from the second output (the maximum value).

### The interquartile range

You likely noticed that the `summary` function produces quartiles 1 and 3, so we could calculate the IQR from these. However, if we are feeling lazy, there is an existing function which will do this for us:  

```{r IQR}

IQR(wd$wdi_internet, na.rm=TRUE)

```

## Visualizing relationships between variables

### Scatterplots

Scatterplots are useful for visualizing relationships between interval/ratio variables. In this course, our convention will be to place **independent variables (IVs)** on the x-axis and **dependent variables (DVs)** on the y-axis.

::: {#nte-ivdv .callout-note}
### IVs and DVs
An **independent variable** is the presumed cause of effects on a **dependent variable**. See the lecture notes for further information.
:::

The variables `wdi_lifexp` (life expectancy at birth) and `wdi_water` (percentage of population with access to improved water) are appropriate for scatterplotting, so we will submit these to `ggplot2::geom_point`. If there is a causal relationship between these two variables, then the most intuitive direction of influence would be from `wdi_water` to `wdi_lifexp`, so we `wdi_water` will be our IV (x-variable) and `wdi_lifexp` our DV (y-variable). 

```{r wdscatter, warning = FALSE, fig.cap = "Access to water vs. Life exp."}
#| label: fig-wdscatter_1
wd %>% 
  ggplot2::ggplot(ggplot2::aes(x = wdi_water, y = wdi_lifexp)) +
  ggplot2::geom_point()

```

We can see a noisy, yet positive relationship between a country's percentage access to an improved water source and its life expectancy at birth. With `ggplot2` we can also run a linear model on data and plot the fit line:

```{r wdscatterlm, message = FALSE, warning = FALSE, fig.cap = "Adding a linear fit line"}
#| label: fig-wdscatter_2
wd %>% 
  ggplot2::ggplot(ggplot2::aes(x = wdi_water, y = wdi_lifexp)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "lm", se = FALSE)

```


We could add country labels to the points to tell us more about the relationship, but, with so many points, the labels would become unreadable. Instead, we can take the `region` variable and use this to colour-code clusters of points, like so:

```{r wdscatterlmcol, message = FALSE, warning = FALSE, fig.cap = "Colouring the regions"}
#| label: fig-wdscatter_3
wd %>%
  dplyr::mutate(Region = haven::as_factor(region)) %>%
  dplyr::filter(!is.na(Region)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = wdi_water, y = wdi_lifexp)) +
  ggplot2::geom_point(ggplot2::aes(colour = Region)) +
  ggplot2::geom_smooth(method = "lm", se = FALSE)
```

Overall, there is a positive relationship between access to water and life-expectancy, but you can see that its strength varies across different regions of the world. To add yet another dimension, you can visualize the relationship within regions:

```{r wdscatterlmcolline, message = FALSE, warning = FALSE, fig.cap = "Adding fit lines per region"}
#| label: fig-wdscatter_4
wd %>%
  dplyr::mutate(Region = haven::as_factor(region)) %>%
  dplyr::filter(!is.na(Region)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = wdi_water, y = wdi_lifexp, colour = Region)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "lm", se = FALSE)
```


### Crosstabulations

Crosstabulations (crosstabs) are a useful method for visualizing relationships among combinations of ordinal and nominal-level variables with relatively few unique categories. For example, let's imagine we are interested how freedom of the press varies across countries in different regions of the world. In the WDI, we can examine this with the variables `region` and  `fhp_status5` (freedom of the press score, as rated by [Freedom House](https://freedomhouse.org/)). `region` is measured at the nominal level (as we cannot rank regions based on name alone), where `fhp_status5` has ranks press freedom from 1 ("Free") to 3 ("Not Free").

A simple crosstab will show us the number of countries within regions which fall into the different categories of press freedom, and also give us the marginal counts^[That is, the counts in the categories of one variable when we ignore the levels of the other.] On this course, our convention will be to place IVs in the columns and DVs in the rows, so our most logical approach would be to place `region` in the columns and `fhp_status5` in the rows.

```{r quickx}
# https://www.datacamp.com/doc/r/frequencies
# https://stackoverflow.com/questions/7535412/create-a-numeric-vector-with-names-in-one-statement

source("customFunctions") 

knitr::kable(quickxtab(haven::as_factor(wd$fhp_status5),haven::as_factor(wd$region),dimm = 2), digits = 2, align = "c")


```

With proportions we can see more:

```{r quickxprop}

knitr::kable(prop.table(quickxtab(haven::as_factor(wd$fhp_status5),haven::as_factor(wd$region),dimm = 2),2), digits = 2, align = "c")
```



## Datawrangling skills: recoding variables

It may sometimes be necessary to add new variables to your dataset, or to transform existing ones. For example, in @sec-mut1 we created a `BMI` variable from existing information about a person's height and mass. In this example, we will look at the variable `wd$wef_mobile` which holds the number of mobile telephone subscriptions per 100 people for each country.

```{r wdmobile}

wd$wef_mobile

```

From this interval/ratio level variable, we will create ordinal categories using the `base::cut` function, as below:

```{r recode}

wd$mobile_recode<-cut(x = wd$wef_mobile, breaks = c(0,50,100,150,max(wd$wef_mobile,na.rm=TRUE)), labels = FALSE)

```

We supply our input data via the `x`, we give our category breakpoints with `breaks`, and we set `labels` to FALSE which means that R will give us simple numerical labels for the output. We request here bins of values from 0 up to to and including 50, from greater than 50 up to and including 100 ... and so on, up to the maximum value in `wef_mobile`. This function also automatically leaves any `NA` as they are, so we do not need to provide any extra input to handle these.

We can compare these variables side-by-side to check that our recode worked as intended:

```{r recodeandorig}

wd %>% 
  dplyr::select(wef_mobile, mobile_recode) %>% 
  print(., n = 25) # use this to show more than the default 10 rows of the data after the selection 

```


## to-do

* crosstab

## Summary

In this chapter, we covered:

* things