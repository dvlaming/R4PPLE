# ISA 2: measures of dispersion and visualizing relationships

## R outcomes

After reading this chapter, you can: 

1. Generate and interpret measures of dispersion 
2. Create and interpret scatterplots (interval/ratio data) and crosstabulations (nominal and ordinal data) 
3. Recode existing data into new variables using `dplyr::mutate` 

## Required packages

You will need the following additional packages:

-   `dplyr` (but we will simply install the `tidyverse` collection so that we also have the pipe operator - `%>%` - loaded)
-   `haven`

```{r}
#| label: install_load
#| message: FALSE 
#| warning: FALSE

library(tidyverse)
library(haven)

```

## Open up your project and a new script file

You created a R project for your ISA work [in the last class](5_r_ISA1.qmd#sec-ISACh1), so open this now and also create a new R script (`Ctrl\Cmd` + `Shift` + `n`) so that you can save today's work.   

## Measures of dispersion

In this course, we will consider three measures of dispersion.

### The standard deviation

The standard deviation is defined as:

$$
S = \sqrt\frac{\sum_{i=1}^{n}{(x_i-\bar{x})^2}}{n-1}
$$


Computation of the standard deviation involves:

1. Calculating the sample mean $\bar{x}$
2. Subtracting $\bar{x}$ from each "raw" value of $x$ to compute deviations
3. Squaring the deviations from step 2 $(x_i - \bar{x})^2$
4. Summing the deviations $\sum_{i = 1}^{n}$
5. Dividing the deviations by the number of observations ($n$) minus 1
6. Taking the square root of 5

The standard deviation can be roughly interpreted as the average deviation from the sample mean in the data. Much like the mean, this measure of dispersion is mot appropriate for interval/ratio level data. 

### The range

The range is simply the difference between the maximum and minimum values in the data, and can be written as:

$$
range = max(x_1, x_2, ..., x_n) - min(x_1, x_2, ..., x_n)
$$

### The interquartile range (IQR)

This represents the spread of the middle 50% of the data and is calculated as:

$$
IQR = Q_3 - Q_1
$$

$Q_3$ and $Q_1$, are, respectively, the 75th and 25th percentiles of the data.To find these for data $x$ with $n$ elements:

* $Q_1(x) = x_{(\frac{n+1}{4})}$
  
* $Q_3(x) = x_{(\frac{3(n+1)}{4})}$
  
Where the position index for the quartile is not a whole number, we can average the values from the two nearest whole number positions to find our quartile. For example, for data with $n = 100$:

* $Q_1(x) = x_{(\frac{101}{4})} = 25.25$

In the above case, we would average the 25th- and 26th-ranked values of $x$ to find $Q_1(x)$.

## Measures of dispersion in R

Let's load in `World_Data.sav`, where the cases (rows) are individual countries. We will then pick out the variable `wdi_internet` whose label we can print with the function `attibutes`, without having to print every value.

```{r ESSload, eval = FALSE}

wd<-haven::read_sav("World_Data.sav")
attributes(wd$wdi_internet)$label
```

```{r ESSloadreal, echo = FALSE}
wd<-haven::read_sav("C:/Users/David/OneDrive - UvA/2025_2026/ISA_24_25/Datasets/World_Data.sav")
attributes(wd$wdi_internet)$label
```

As you can see, this variable shows the percentage of individuals using the internet as percentage of population. We can will use `summary` to display some measures of central tendency:

```{r wdsummary}
summary(wd$wdi_internet)
```

(Along with these, we can see that four countries had [`NA` values](2_r_firstdata.qmd#nte-na) for this variable. We need to bear this in mind as we go further, because R will try to get answers out of `NA` entries where no answers are to be had.) 

### The standard deviation

```{r wdsd}

sd(wd$wdi_internet, na.rm = TRUE)

```

(The `na.rm = TRUE` argument above tells R to remove any values of `NA` before performing the requested operation.)


### The range

```{r wdrange}

range(wd$wdi_internet, na.rm = TRUE)

```

While the function runs, it actually returns the minimum and maximum values of the dataset, rather than the difference between them. We can add some extra code to calculate this:

```{r wdrangediff}

range(wd$wdi_internet, na.rm = TRUE)[2] - range(wd$wdi_internet, na.rm = TRUE)[1] 

```

This tells R to subtract the first output argument from the `range` function (the minimum value) from the second output (the maximum value).

### The interquartile range

You likely noticed that the `summary` function produces quartiles 1 and 3, so we could calculate the IQR from these. However, if we are feeling lazy, there is an existing function which will do this for us:  

```{r IQR}

IQR(wd$wdi_internet, na.rm=TRUE)

```


## Datawrangling skills: recoding variables

It may sometimes be necessary to add new variables to your dataset, or to transform existing ones. For example, in @sec-mut1 we created a `BMI` variable from existing information about a person's height and mass. In this example, we will look at the variable `wd$wef_mobile` which holds the number of mobile telephone subscriptions per 100 people for each country.

```{r wdmobile}

wd$wef_mobile

```

From this interval/ratio level variable, we will create ordinal categories using the `base::cut` function, as below:

```{r recode}
# https://davidhughjones.medium.com/case-when-is-a-code-smell-and-across-is-a-code-smell-too-8f8e33429e34

wd$mobile_recode<-cut(x = wd$wef_mobile, breaks = c(0,50,100,150,max(wd$wef_mobile,na.rm=TRUE)), labels = FALSE)

```

We supply our input data via the `x`, we give our category breakpoints with `breaks`, and we set `labels` to FALSE which means that R will give us simple numerical labels for the output. This function also automatically leaves any `NA` as they are, so we do not need to provide any extra input to handle these.


## To-do:

* finish sim card recode
* summary


## Summary

In this chapter, we covered:

* things